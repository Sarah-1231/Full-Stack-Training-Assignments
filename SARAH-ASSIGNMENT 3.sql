--Answer following questions
--1.	In SQL Server, assuming you can find the result by using both joins and subqueries, which one would you prefer to use and why?
--I will prefer to use JOINS. Because it has better performance with less query cost. 
--2.	What is CTE and when to use it?
--A Common Table Expression (CTE) is a temporary named result set that you can reference within a SELECT, INSERT, UPDATE, or DELETE statement.
--The CTE can be used as a temporary view and enables recursive queries. It improves readability and eases maintenance of complex queries. CTEs can be defined in user-defined routines, such as functions, stored procedures, triggers, or views. 
--3.	What are Table Variables? What is their scope and where are they created in SQL Server?
--The table variable is a special type of the local variable that helps to store data temporarily, similar to the temp table in SQL Server. In fact, the table variable provides all the properties of the local variable, but the local variables have some limitations, unlike temp or regular tables.
--A table variable is scoped to the stored procedure, batch, or user-defined function just like any local variable you create with a DECLARE statement.
--A table variable is created in tempdb system database.
--4.	What is the difference between DELETE and TRUNCATE? Which one will have better performance and why?
--Delete command is useful to delete all or specific rows from a table specified using a Where clause? The truncate command removes all rows of a table. We cannot use a Where clause in this.
--Delete command logs entry for each deleted row in the transaction log? The truncate command does not log entries for each deleted row in the transaction log.
--Delete command is slower than the Truncate command? TRUNCATE is fasterthan the delete command
--Delete removes rows one at a time; Truncate removes all rows in a table by deallocating the pages that are used to store the table data
--Delete is a DML command; Truncate is DDL command
--Delete requires more transaction log space than the truncate command; Truncate requires less transaction log space than the truncate command.
--Delete command removes the rows matched with the where clause. It also does not remove the columns, indexes, constraints, schema; The truncate command only removes all rows of a table. It does not remove the columns, indexes, constraints, and schema.
--We need to use them according to difference scenarios and there are no clear advantages. However, the TRUNCATE command is faster than the DELETE command.
--5.	What is Identity column? How does DELETE and TRUNCATE affect it?
--An identity column is a column (also known as a field) in a database table that is made up of values generated by the database. In SQL Server, we create an identity column to auto-generate incremental values. It generates values based on predefined seed (Initial value) and step (increment) value. For example, suppose we have an Employee table and we want to generate EmployeeID automatically.
--When the DELETE statement is executed without WHERE clause it will delete all the rows. However, when a new record is inserted the identity value is increased from by 1. It does not reset but keep on increasing.
--When the TRUNCATE statement is executed it will remove all the rows. However, when a new record is inserted ,TRUNCATE resets the identity value to the original seed value of the table.
--6.	What is difference between “delete from table_name” and “truncate table table_name”?
--Truncate can be used to delete the entire data of the table without maintaining the integrity of the table. Delete statement can be used for deleting the specific data.
--Write queries for following scenarios
--All scenarios are based on Database NORTHWND.
--1.	List all cities that have both Employees and Customers.
SELECT City 
FROM Customers
WHERE City IN (SELECT City
FROM Employees)
--2.	List all cities that have Customers but no Employee.
--a.	Use sub-query
SELECT CITY  
FROM Customers
WHERE City NOT IN (SELECT CITY 
FROM Employees)
--b.	Do not use sub-query
SELECT C.City
FROM Customers C LEFT JOIN Employees E ON C.City = E.City
WHERE E.CITY IS NULL
--3.	List all products and their total order quantities throughout all orders.
SELECT P.ProductID, SUM(OD.Quantity) TOTAL_QUANTITIES
FROM Products P LEFT JOIN [Order Details] OD ON P.ProductID = OD.ProductID
GROUP BY P.ProductID
--4.	List all Customer Cities and total products ordered by that city.
SELECT C.City, SUM(OD.Quantity) TOTAL_PRODUCTS
FROM [Order Details] OD LEFT JOIN Orders O ON OD.OrderID = O.OrderID LEFT JOIN Customers C ON O.CustomerID = C.CustomerID
GROUP BY C.City
--5.	List all Customer Cities that have at least two customers.
--a.	Use union
SELECT City, COUNT(CustomerID) COUNTED_CUSTOMERS
FROM Customers
GROUP BY City
HAVING COUNT(CustomerID) >=2
--b.	Use sub-query and no union
--6.	List all Customer Cities that have ordered at least two different kinds of products.
SELECT C.City, COUNT(DISTINCT OD.OrderID) KINDS_OF_PRODUCTS
FROM [Order Details] OD LEFT JOIN Orders O ON OD.OrderID = O.OrderID LEFT JOIN Customers C ON C.CustomerID = O.CustomerID
GROUP BY C.City
HAVING COUNT(DISTINCT OD.ProductID) >=2
--7.	List all Customers who have ordered products, but have the ‘ship city’ on the order different from their own customer cities.
SELECT CustomerID 
FROM Customers 
WHERE CustomerID IN 
(SELECT C.CustomerID
FROM [Order Details] OD LEFT JOIN Orders O ON OD.OrderID = O.OrderID LEFT JOIN Customers C ON C.CustomerID = O.CustomerID
WHERE C.City<>O.ShipAddress)
--8.	List 5 most popular products, their average price, and the customer city that ordered most quantity of it.
(select top 5 OD.ProductID from Orders O left join [Order Details] OD 
on O.OrderID = OD.OrderID left join Customers C on O.CustomerID = C.CustomerID
group by OD.ProductID 
ORDER BY count(OD.ProductID) desc)
group by OD.ProductID,C.City) as OOO 
where rank_no = 1
--9.	List all cities that have never ordered something but we have employees there.
--a.	Use sub-query
Select distinct(C.City) from [Order Details] OD left join Orders O on OD.OrderID = O.OrderID
left join Customers C on C.CustomerID = O.CustomerID where C.City not in 
(select E.City from Employees E)
--b.	Do not use sub-query
Select distinct(C.City) from [Order Details] OD left join Orders O on OD.OrderID = O.OrderID
left join Customers C on C.CustomerID = O.CustomerID left join Employees E
on E.City = C.City where E.City is Null
--10.	List one city, if exists, that is the city from where the employee sold most orders (not the product quantity) is, and also the city of most total quantity of products ordered from. (tip: join  sub-query)
select top 1 City from Orders O left join Customers C on 
O.CustomerID = C.CustomerID group by City order by count(O.OrderID) desc
--11. How do you remove the duplicates record of a table?
--It can be done by many ways in sql server the most simplest way to do so is: Insert the distinct rows from the duplicate rows table to new temporary table. Then delete all the data from duplicate rows table then insert all data from temporary table which has no duplicates as shown below.
--12. Sample table to be used for solutions below- Employee (empid integer, mgrid integer, deptid integer, salary money) Dept (deptid integer, deptname varchar(20))
-- Find employees who do not manage anybody.
Select e1.empid from Employees e1 left join Employees e2 on 
e1.mgrid = e1.empid where e1.mgrid is null
--13. Find departments that have maximum number of employees. (solution should consider scenario having more than 1 departments that have maximum number of employees). Result should only have - deptname, count of employees sorted by deptname.
Select E.deptname, CntEmployees from 
(Select E.deptname, count(empid) CntEmployees, 
rank() over(order by count(empid) desc)) rnk 
from Employee E left join Dept D on E.deptid = D.deptid group by E.deptname) dt 
where rnk = 1 order by deptname
--14. Find top 3 employees (salary based) in every department. Result should have deptname, empid, salary sorted by deptname and then employee with high to low salary.
Select deptname, empid, salary from 
(Select E.deptname, E.empid, E.salary, 
rank() over(partition by employeeid order by salary desc)) rnk 
from Employee E left join Dept D on 
E.deptid = D.deptid group by E.deptname) dt 
where rnk <=3 order by deptname